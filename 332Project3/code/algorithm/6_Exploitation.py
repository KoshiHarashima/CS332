# 6_Exploitation.py
# Exploitative algorithm: waits and exploits when opponent bids below value
# Strategy:
# 1. Initially doesn't bid (or bids very low)
# 2. Observes opponent's bids from losses
# 3. When opponent bids below our value, we bid optimally (slightly above opponent)

import numpy as np
from typing import List, Tuple

def exploitation_algorithm(player_id: int, value: float, round_num: int,
                          history: List[Tuple[float, float, bool, float]],
                          env_state: dict) -> float:
    """
    Exploitative algorithm: waits and exploits when opponent bids low
    
    Full Information + Full Feedback: Can directly observe opponent's bids.
    
    Strategy:
    - Initially observes by bidding minimum (0)
    - Uses exponential smoothing over past 10 opponent bids for prediction
    - When predicted opponent bid < value*0.9, maximizes expected utility
      (accounts for ties with 0.5 probability allocation)
    
    Args:
        player_id: player ID (0 or 1)
        value: player's value (v)
        round_num: current round number
        history: list of (bid, utility, won, opponent_bid) tuples for this player
                 - bid: player's bid
                 - utility: player's utility
                 - won: whether player won
                 - opponent_bid: opponent's bid (Full Feedback - directly observed)
        env_state: dict with additional info
    
    Returns:
        bid: selected bid
    """
    # Initial observation phase
    observation_rounds = env_state.get('observation_rounds', 20)
    
    # Get unified bid grid (k discrete arms in [0, value])
    k = env_state.get('k', 100)
    bid_grid = np.linspace(0, value, k)
    
    if round_num < observation_rounds:
        # Observation phase: bid minimum (0) to observe opponent
        return bid_grid[0]  # bid_grid[0] = 0 (minimum bid)
    
    # Full Feedback: Extract opponent's bids directly from history
    # History format: (bid, utility, won, opponent_bid)
    opponent_bids = []
    for entry in history:
        if len(entry) >= 4:
            _, _, _, opp_bid = entry
            opponent_bids.append(opp_bid)
        else:
            # Backward compatibility: if old format, estimate from won/lost
            bid, _, won = entry[:3]
            if not won:  # We lost, so opponent_bid >= our_bid
                opponent_bids.append(bid)  # Lower bound
    
    if len(opponent_bids) == 0:
        # No opponent bids observed yet, continue observing
        return bid_grid[0]  # bid_grid[0] = 0 (minimum bid)
    
    # Exponential smoothing prediction over past 10 bids
    # Use last 10 bids (or all available if fewer than 10)
    smoothing_window = 10
    recent_bids = opponent_bids[-min(smoothing_window, len(opponent_bids)):]
    
    # Exponential smoothing: alpha (smoothing parameter)
    # Higher alpha = more weight on recent observations
    alpha = 0.3  # Standard value for exponential smoothing
    
    # Calculate exponentially weighted average
    # Newer values get higher weights: weight[i] = alpha * (1-alpha)^(n-1-i)
    # where i=0 is oldest, i=n-1 is newest
    n = len(recent_bids)
    weights = np.array([alpha * ((1 - alpha) ** (n - 1 - i)) 
                        for i in range(n)])
    weights = weights / np.sum(weights)  # Normalize (should sum to 1)
    predicted_opponent_bid = np.sum(weights * np.array(recent_bids))
    
    # Exploitation threshold: value * 0.9
    # Only exploit if predicted opponent bid is below threshold
    exploitation_threshold = value * 0.9
    
    if predicted_opponent_bid < exploitation_threshold:
        # Exploit: maximize expected utility on bid grid
        # Use empirical distribution from observed opponent bids to calculate P(win)
        # and find bid that maximizes (value - bid) * P(win|bid)
        
        # Calculate win probabilities for each bid in grid (with tie handling)
        win_probs = calculate_win_probability(opponent_bids, bid_grid)
        
        # Expected utility = (value - bid) * P(win|bid)
        expected_utility = (value - bid_grid) * win_probs
        
        # Only consider bids < value (ensure positive utility)
        valid_mask = bid_grid < value
        if not np.any(valid_mask):
            return bid_grid[0]
        
        # Find maximum among valid bids
        valid_utility = expected_utility.copy()
        valid_utility[~valid_mask] = -np.inf
        optimal_idx = np.argmax(valid_utility)
        
        return bid_grid[optimal_idx]
    else:
        # Predicted opponent bid >= threshold, continue observing
        return bid_grid[0]  # bid_grid[0] = 0 (continue observing)


def calculate_win_probability(observed_bids: List[float], bid_grid: np.ndarray) -> np.ndarray:
    """
    Calculate P(win|bid=b) for each bid in bid_grid, strictly handling ties.
    
    In First Price Auction with tie-breaking:
    - P(win|bid=b) = P(opponent_bid < b) + 0.5 * P(opponent_bid == b)
    
    Args:
        observed_bids: list of opponent bids observed so far
        bid_grid: array of bid values to evaluate
    
    Returns:
        win_probs: array of win probabilities for each bid in bid_grid
    """
    n_obs = len(observed_bids)
    win_probs = np.zeros_like(bid_grid)
    
    if n_obs == 0:
        # No observations: assume uniform distribution
        max_val = np.max(bid_grid)
        if max_val > 0:
            win_probs = np.clip(bid_grid / max_val, 0.0, 1.0)
            return win_probs
        else:
            return np.full_like(bid_grid, 0.5)
    
    # For each bid in grid, calculate P(win)
    # Use relative tolerance for floating point comparison
    rtol = 1e-9
    atol = 1e-9
    
    for i, bid in enumerate(bid_grid):
        # Count observations
        count_less = sum(1 for ob in observed_bids if ob < bid)
        # Use np.isclose with appropriate tolerance for tie detection
        count_equal = sum(1 for ob in observed_bids if np.isclose(ob, bid, rtol=rtol, atol=atol))
        
        # P(win|bid) = P(opponent_bid < bid) + 0.5 * P(opponent_bid == bid)
        p_less = count_less / n_obs
        p_equal = count_equal / n_obs
        win_probs[i] = p_less + 0.5 * p_equal
    
    return win_probs

