# 6_Exploitation.py
# Exploitative algorithm: waits and exploits when opponent bids below value
# Strategy:
# 1. Initially doesn't bid (or bids very low)
# 2. Observes opponent's bids from losses
# 3. When opponent bids below our value, we bid optimally (slightly above opponent)

import numpy as np
from typing import List, Tuple

def exploitation_algorithm(player_id: int, value: float, round_num: int,
                          history: List[Tuple[float, float, bool, float]],
                          env_state: dict) -> float:
    """
    Exploitative algorithm: waits and exploits when opponent bids low
    
    Full Information + Full Feedback: Can directly observe opponent's bids.
    
    Strategy:
    - Initially observes by bidding 0.2*v for observation_rounds (default: 10)
    - Requires minimum observations (default: 5) before exploiting
    - Uses exponential smoothing with sequential update: pred = alpha*last + (1-alpha)*prev_pred
    - When predicted opponent bid < value*threshold_ratio (default: 0.75), maximizes expected utility
      (accounts for ties with 0.5 probability allocation)
    - Only uses Full Feedback opponent bids (no backward compatibility lower bounds)
    - Configurable parameters in env_state:
      - observation_rounds: initial observation phase length (default: 10)
      - min_observations: minimum opponent bids needed before exploiting (default: 5)
      - smoothing_alpha: exponential smoothing parameter (default: 0.3)
      - exploitation_threshold_ratio: threshold ratio for exploitation (default: 0.5)
    
    Args:
        player_id: player ID (0 or 1)
        value: player's value (v)
        round_num: current round number
        history: list of (bid, utility, won, opponent_bid) tuples for this player
                 - bid: player's bid
                 - utility: player's utility
                 - won: whether player won
                 - opponent_bid: opponent's bid (Full Feedback - directly observed)
        env_state: dict with additional info
    
    Returns:
        bid: selected bid
    """
    # Initial observation phase
    observation_rounds = env_state.get('observation_rounds', 10)  # Reduced default from 20 to 10
    min_observations = env_state.get('min_observations', 5)  # Minimum observations before exploiting
    
    # Get unified bid grid (k discrete arms in [0, value])
    k = env_state.get('k', 100)
    bid_grid = np.linspace(0, value, k)
    
    # Initial observation bid: 0.2*v
    initial_bid = value * 0.2
    initial_bid_idx = np.argmin(np.abs(bid_grid - initial_bid))
    initial_bid_value = bid_grid[initial_bid_idx]
    
    if round_num < observation_rounds:
        # Observation phase: bid 0.2*v to observe opponent
        return initial_bid_value
    
    # Full Feedback: Extract opponent's bids directly from history
    # Only use Full Feedback data (len(entry) >= 4) - no backward compatibility lower bounds
    # History format: (bid, utility, won, opponent_bid)
    opponent_bids = []
    for entry in history:
        if len(entry) >= 4:
            _, _, _, opp_bid = entry
            opponent_bids.append(opp_bid)
        # Skip backward compatibility - only use Full Feedback data
    
    if len(opponent_bids) == 0:
        # No opponent bids observed yet, continue observing
        return initial_bid_value
    
    # Ensure minimum observations before exploiting
    if len(opponent_bids) < min_observations:
        return initial_bid_value  # Continue observing
    
    # Exponential smoothing with sequential update: pred = alpha*last + (1-alpha)*prev_pred
    alpha = env_state.get('smoothing_alpha', 0.3)  # Standard value for exponential smoothing
    
    # Initialize or retrieve previous prediction from env_state
    if 'predicted_opponent_bid' not in env_state:
        # First prediction: use the first observed bid
        env_state['predicted_opponent_bid'] = opponent_bids[0]
    
    prev_pred = env_state['predicted_opponent_bid']
    last_opp_bid = opponent_bids[-1]  # Most recent opponent bid
    
    # Sequential update: pred = alpha*last + (1-alpha)*prev_pred
    predicted_opponent_bid = alpha * last_opp_bid + (1 - alpha) * prev_pred
    
    # Update env_state with current prediction for next round
    env_state['predicted_opponent_bid'] = predicted_opponent_bid
    
    # Exploitation threshold: configurable, default to value * 0.5
    # Only exploit if predicted opponent bid is below threshold (ensures higher win probability)
    threshold_ratio = env_state.get('exploitation_threshold_ratio', 0.5)
    exploitation_threshold = value * threshold_ratio
    
    if predicted_opponent_bid < exploitation_threshold:
        # Exploit: maximize expected utility on bid grid
        # Use empirical distribution from observed opponent bids to calculate P(win)
        # and find bid that maximizes (value - bid) * P(win|bid)
        
        # Calculate win probabilities for each bid in grid (with tie handling)
        win_probs = calculate_win_probability(opponent_bids, bid_grid)
        
        # Expected utility = (value - bid) * P(win|bid)
        expected_utility = (value - bid_grid) * win_probs
        
        # Only consider bids < value (ensure positive utility)
        valid_mask = bid_grid < value
        if not np.any(valid_mask):
            return bid_grid[0]
        
        # Find maximum among valid bids
        valid_utility = expected_utility.copy()
        valid_utility[~valid_mask] = -np.inf
        optimal_idx = np.argmax(valid_utility)
        
        return bid_grid[optimal_idx]
    else:
        # Predicted opponent bid >= threshold, continue observing
        return initial_bid_value  # Continue observing with 0.2*v


def calculate_win_probability(observed_bids: List[float], bid_grid: np.ndarray) -> np.ndarray:
    """
    Calculate P(win|bid=b) for each bid in bid_grid, strictly handling ties.
    
    In First Price Auction with tie-breaking:
    - P(win|bid=b) = P(opponent_bid < b) + 0.5 * P(opponent_bid == b)
    
    Args:
        observed_bids: list of opponent bids observed so far
        bid_grid: array of bid values to evaluate
    
    Returns:
        win_probs: array of win probabilities for each bid in bid_grid
    """
    n_obs = len(observed_bids)
    win_probs = np.zeros_like(bid_grid)
    
    if n_obs == 0:
        # No observations: assume uniform distribution
        max_val = np.max(bid_grid)
        if max_val > 0:
            win_probs = np.clip(bid_grid / max_val, 0.0, 1.0)
            return win_probs
        else:
            return np.full_like(bid_grid, 0.5)
    
    # For each bid in grid, calculate P(win)
    # Use relative tolerance for floating point comparison
    rtol = 1e-9
    atol = 1e-9
    
    for i, bid in enumerate(bid_grid):
        # Count observations
        count_less = sum(1 for ob in observed_bids if ob < bid)
        # Use np.isclose with appropriate tolerance for tie detection
        count_equal = sum(1 for ob in observed_bids if np.isclose(ob, bid, rtol=rtol, atol=atol))
        
        # P(win|bid) = P(opponent_bid < bid) + 0.5 * P(opponent_bid == bid)
        p_less = count_less / n_obs
        p_equal = count_equal / n_obs
        win_probs[i] = p_less + 0.5 * p_equal
    
    return win_probs

